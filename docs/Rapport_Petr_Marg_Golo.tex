\documentclass[a4paper,10pt,openany,oneside]{book}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage[hidelinks]{hyperref}
\usepackage{wrapfig}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings} %Pour le code
\usepackage{amsmath}
\usepackage{changepage}
\usepackage{color}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage[left=3cm,right=3cm,top=3cm,bottom=3cm,headsep=1cm]{geometry}
\usepackage{enumitem}
\setitemize{topsep=5pt}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\definecolor{myblue}{rgb}{0,0,1}



\lstset{frame=tb,
  language=C++,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\normalsize,
  numbersep=7pt,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4
}

\begin{document}
\title{Rapport P2 Qt}
\author{Damian Petroff, Sergiy Goloviatinski, Raphaël Margueron}
\maketitle

\tableofcontents
\thispagestyle{empty}


\chapter{Introduction}
\setcounter{page}{1}
\thispagestyle{headings}

\chapter{Analyse}
\thispagestyle{headings}

\section{Spécifications}

\chapter{Conception}
\thispagestyle{headings}

\section{Cas d'utilisation}

\section{Planification initiale}

\section{Planification finale}

\section{Diagramme de classe}

\section{Schéma procédural d'utilisation}

\chapter{Développement}
\thispagestyle{headings}
\section{Interface graphique}
L'interface graphique se divise en 3 parties:
\begin{itemize}
\item $TopView$ : Vue fixe se trouvant toujours en haut de l'interface et qui contient:
\begin{itemize}
\item L'heure et la date dans le jeu
\item Des indicateurs d'argent, de bonheur et de population disponible pour le joueur avec le delta entre chaque seconde
\item Une $SpinBox$ permettant de régler le niveau d'impôts
\item Le nom de la carte, pouvant être modifié si on clique dessus
\item Des $Slider$ pour régler le volume de la musique et des effets
\item Des boutons pour charger,sauvegarder et quitter la partie
\item La valeur de la seed utilisée pour générer la carte
\end{itemize}
\item $MapView$ : Contient le terrain de jeu, les différents raccourcis claviers (même quand cette vue n'a pas le focus) et actions de souris qui sont dans son focus influencent sur cette vue:
\begin{itemize}
\item Translation dans la vue (Raccourcis: A S D W ou flèches directionnelles)
\item Zoom dans la vue (Raccourcis : + - ou molette de la souris)
\item Afficher/masquer la grille (Raccourci: G)
\item Afficher/masquer les rayons d'effets de tous les bâtiments qui en ont un (Raccourci: F)
\item Afficher le rayon d'effet d'un bâtiment s'il en a un quand un clique dessus
\end{itemize}
\item $GuiView$ : Vue contenant les boutons permettant de:
\begin{itemize}
\item Choisir la catégorie de bâtiment à poser (Raccourcis clavier disponible depuis n'importe quelle vue: F1 à F9)
\item Les différents bâtiments à poser selon la catégorie choisie (Raccourcis claviers de 1 à 0)
\item Un bouton pour poser des routes disponibles dans toutes les catégories (Raccourci: Q)
\item Un bouton pour supprimer un bâtiment/route disponible dans toutes les catégories (Raccourci: R)
\end{itemize}
\end{itemize}

\section{Génération des sols}
Pour la gestion du terrain, nous avons décidé d'avoir deux types de sol : l'eau et l'herbe. Sur l'herbe, il est possible d'ajouter des bâtiments et sur l'eau non.

Pour pouvoir avoir des cartes auto-générée, nous avons décide d'utiliser un algorithme de bruit de Perlin. Nous n'allons pas aller dans les détails du fonctionnement du bruit de Perlin, dans ce rapport. Mais son principe est le suivant: il permet d'avoir des nombres aléatoires qui sont proche les uns de autres en function d'une seed(pour l'aléatoire, initialisé au début) et de 1, 2 ou X dimensions (trois dans celui que nous avons utilisés, mais que 2 utilisés). Vu que les outputs de la function de bruit de Perlin sont les mêmes quand nous utilisons les mêmes inputs. Nous pouvons la considérer comme une fonction à plusieurs variables (qui sont les dimensions et la seed). Changer la seed donne des résultats complètement différent mais changer les autres variables change peu entre chaque valeur.

\[bruit = perlin(seed, x, y, z)\]

Les nombres aléatoires que nous récupérons de la function sont des nombres flottant entre 0 et 1.
Leurs distribution sont sous la forme d'une distribution normal.
\[y=e^{-x^{2}}\]

Pour pouvoir générer la carte nous parcourons toutes les cases de la carte (selon x et y). Et "nous déplaçons sur le fonction de Perlin" d'un certain offset (qui est un multiple des index des cases).
\section{Gestion des cases de la carte}
Nous stockons les cases de la carte dans un $QArray$ d'une longueur $nbCases^{2}$

Une case à la coordonnée $X;Y$ dans la grille de cases représentant la carte correspond à l'élément se trouvant à l'indice $X+Y nbCases$ dans le $QArray$

Une case de la carte est représenté par la classe $MapTile$ dérivé de la classe $QGraphicsRectItem$ et contient les attributs suivants:
\begin{itemize}
\item bOccupied (boolean): dit si la case est occupée par un bâtiment ou de l'eau ou pas
\item x (int): coordonnée en x dans la matrice contenant les MapTile
\item y (int): coordonnée en y dans la matrice contenant les MapTile
\item bId (int): id du type de bâtiment (tous les hôpitaux ont la même bId p. ex)
\item unique BId (int): id unique du bâtiment (chaque bâtiment posé aura une id unique différente)
\item mainTileX (int): coordonnée en X de la case principale (en haut à gauche), utile pour les bâtiments d'une largeur ou hauteur supérieures à 1
\item mainTileY (int): même chose que mainTileX mais la coordonnée Y
\item buildingWIdth (int): largeur en nombre de cases d'un bâtiment
\item buildingHeight (int): hauteur en nombre de cases d'un bâtiment
\item bPix (boolean): indique si la case a une texture ou pas
\item buildImage ($QGraphicsPixmapItem*$): Pointeur vers la texture du bâtiment/route qui se trouve sur la case
\end{itemize}
\section{Routes et bâtiments}
Pour la gestion des routes et des bâtiments nous sommes parti sur une approche plutôt simple qui est d'avoir divisé en trois classe qui chacune des rôles spécifique. Une qui décrit les caractéristiques propre à chaque bâtiments : les constantes -> ConstantBuilding. Une seconde classe qui décrit une bâtiment spécifique à la partie -> Building. Et une troisième qui sert de gestionnaires de building, 'classe tableau' -> BuildingManager. 

\subsection{Constant Building}
Constant Building contient une function de construction d'un tableau d'objet de 'soit même'. Chacun de ces objet représente un bâtiment avec toutes ces caractéristiques internes, par exemple : le prix de construction, la liste des bâtiments nécessaires pour sa construction ou encore sa catégorie dans l'affichage de l'HUD.

Liste de caractéristique de base de chaque bâtiment :
\begin{itemize}
	\item Nom à l'affichage
	\item Catégorie
	\item Prix
	\item Largeur (au sol)
	\item Hauteur (au sol)
	\item Une liste de case ignoré (non-implémenté, pour avoir la possibilité d'avoir de bâtiment non rectangulaire)
	\item Type de pré-requis (Ou / Et)
	\item Une liste d'identifiant de bâtiment pré-requis.
	\item La sommes des pré-requis nécessaires. 
\end{itemize}

Nous avons choisi d'avoir des objets au lieu d'une liste de constante, pour pouvoir avoir la possibilité d'y ajouter des fonctions pour ces objets ce qui nous a permis d'avoir un autre set de valeur basé sur les caractéristiques de base, voir ci-dessous. Cela nous permet ajuster facilement le jeu et d'avoir une sorte de progression linaire du jeu.

Liste des caractéristique dérivé :
\begin{itemize}
  \item Prix/Secondes = \(Prix / 4\)
  \item Efficacité = \((Prix/10)^{1.4} + 10\) (arrondi au multiple de 25 le plus proche)
  \item Rayon d'action = \(Log10(PrixParSecondes*Efficacite + 1)\) (Arrondi au multiple de 5 le plus proche)
  \item Poids du Bâtiment dans les pré-requis = \(Prix / 10\)
\end{itemize}

On remarque donc que le prix du bâtiment influe directement sur tous les caractéristique qui définisse si le bâtiment est performant ou non.

Fonctionnement des pré-requis :
Les pré-requis sont un aspect que nous considérons comme l'élément primordiale permettant au jeu d'avoir une progression. Le principe est le suivant.

Pour qu'un bâtiment soit accessible à la construction il faut qu'il respect les règles suivantes si son type de pré-requis est 'ou' :
La somme des poids de tous les bâtiments qui sont actuellement posé qui sont dans la liste des bâtiments en pré-requis du bâtiment désiré doit être supérieur ou égal à la somme des pré-requis nécessaires.
Exemple :
Pour poser un Laboratoire médical : Il faut au moins une somme de 6.
La liste des bâtiments pré-requis et des poids pour le laboratoire est la suivante :
\begin{itemize}
	\item Clinique : 1
	\item Hôpital : 5
\end{itemize}
Il y a donc au moins trois possibilités pour arrivé à remplir cette demande :
\begin{itemize}
	\item 6x Clinique
	\item 1x Clinique et 1x Hôpital (Meilleur solution, au niveau du prix par seconde de le efficacité sur un grand rayon)
	\item 2x Hôpital
\end{itemize}

Pour les pré-requis en 'et' :
Il faut en plus que pour les pré-requis en 'ou', avoir au moins un bâtiment de chaque type de la liste des bâtiments pré-requis.
Exemple :
Pour poser une Tour Eiffel : Il faut au moins une somme de 11.5
La liste des bâtiments pré-requis et des poids pour le laboratoire est la suivante :
\begin{itemize}
	\item Hôpital : 5
	\item Caserne de pompier : 1.5
	\item Quartiers généraux : 5
\end{itemize}
Il y a donc au moins une possibilité pour arrivé à remplir cette demande, qui est d'avoir une bâtiment de chaque. A noter que dans ce cas, la somme de pré-requis n'influence pas pour ce bâtiment, mais on pourrai imaginer qu'un bâtiment aille une somme plus grande que la somme de chaque bâtiment pré-requis et la la somme aurai une influence.

\subsection{Building}
La classe building décrit un bâtiment posé dans une partie. Il est décris les caractéristiques suivantes :
\begin{itemize}
	\item Un identifiant unique
	\item Un identifiant du type de bâtiment (de ConstantBuilding)
	\item Une position X/Y
	\item Un angle de rotation (De quel côté est posé le bâtiment, non-implémenté)
	\item Une population
\end{itemize}
On peut donc noter que cet objet est rendu assez 'léger' car la plus part de ce qui le décrit est géré par l'identifiant constant building. Nous pouvons donc avoir beaucoup de bâtiment et avoir une emprunte mémoire peu conséquente.

\subsection{Building Manager}
Cette classe permet de gérer une liste de bâtiment de la classe Building. On peut exécuté les actions suivante :
\begin{itemize}
	\item Ajouter un bâtiments (qui est ajoutable selon les pré-requis)
	\item Supprimer des bâtiments 
	\item Récupérer la population total de la ville.
	\item Récupérer le bonheur moyen de la ville.
	\item Récupérer la somme des prix par seconde.
\end{itemize}

Les fonctions de récupération retournent un valeur stocké mais la valeur stock est recalculé si le besoin l'est, par exemple le bonheur moyen ne varie pas selon le temps mais si un nouveau bâtiment est placé on doit donc recalculer le bonheur moyen.

\section{Déroulement en fonction du temps de la partie}
Le jeu se déroule en fonction du temps sur divers aspects, cela permet d'avoir une progression. Toute les secondes certain calcules sont effectuer pour donner l'impression au joueur que le temps défile. Voici les trois indicateurs que nous avons choisis de représenté :
\begin{itemize}
	\item Bonheur : Représente une satisfaction de la population sur la ville construite.
	\item Argent : Le solde que la ville a à disposition pour faire de modifications.
	\item Population : Le nombre d'habitant qui réside actuellement dans la ville.
\end{itemize}
Malgré nos efforts à rendre le jeu jouable. Nous avons parfaitement conscience que le jeu n'est pas très bien équilibré à ce niveau.
\subsection{Temps : Heure et Date}
Pour pouvoir donner un aspect réaliste au jeu, nous avons choisi de prendre la date du jour comme date du début de jeu. Puis toute les secondes, le temps virtuel augmente de une heure. Nous avons donc pour 60 minutes de jeu effectives correspondent à 150 jours virtuel.

\subsection{Bonheur}
La jauge de bonheur global est un nombre qui varie entre 0 et 250. Il est basé sur la moyenne du bonheur de toutes la résidence de la ville. 
\newline
Pour chaque résidence, un bonheur résidentiel est calculé.
Les paramètres suivant influence le bonheur résidentiel :
\begin{itemize}
	\item Les bâtiments public autours de la résidence.
	\item La proximité de ce bâtiment public.
\end{itemize}
Plus y il a de bâtiment efficace et proche d'un résidence pour le bonheur sera élevé pour cette résidence.
Les paramètres suivant influence le bonheur global.
\begin{itemize}
	\item Le bonheur résidentiel moyen
	\item Les impôts en vigueur actuellement
\end{itemize}
Concernant les impôts nous avons fixé un multiplicateur à 100\% qui est au point neutre des impôts (8.0\%). Et qui peut varier entre 0\%-200\%. Plus le impôts sont bas plus les habitants seront content et à l'inverse plus les impôts sont élevé moins les habitants sont content.
\newline
Pour ajouter un effet de lissage sur le temps du bonheur, nous avons implémenté un algorithme assez simple qui est le suivant :
\[bohneur = 20\% ancienBohneur + 80\% bohneurResidentielMoyen\]
L'ancien bonheur correspond au bonheur qui était en vigueur la seconde précédente.

\subsection{Population}
Nous avons actuellement une population fixe mais il avait été prévu d'avoir un accroissement de la population en fonction du bonheur. Ainsi que des logements qui se construisent automatique au bords des routes en conséquence.

\subsection{Argent}
Pour l'argent il y a principalement deux facteurs qui influence les revenus ou non de la ville.
\begin{itemize}
	\item En négatif : Le prix par seconde des bâtiments public installés
	\item En positif : Le impôts prélevé aux habitants.
\end{itemize}
Pour les revenus des impôts, nous avons fais une règle un peu fantaisiste qui est que les habitants payent des impôts relatif à leur satisfaction à la ville. Ce qui impose au joueur d'avoir une ville heureuse pour pouvoir avoir de l'argent. Ce qui nous évite permis de contourné le faites que les flux de population ne sont pas géré. Car initialement les revenus n'était pas censé être influencé par le bonheur mais seulement par la population. Ce qui nous apportai une liaison en triangle entre les trois indicateurs.
Selon ce schéma Bonheur -> Population -> Argent -> Bonheur(Indirectement) et la boucle est fermé.

\subsection{Dérivé des indicateurs}
Lors du déroulement en fonction du temps nous avons trouvé intéressant d'avoir d'affiche la variation de chaque indicateurs entre les deux derniers calculs (la dérivée en fonction du temps). Calculé de cette façon. \[deltaValeur = nouvelleValeur - ancienneValeur\]

\section{Gestion du son}
Pour la gestion du son nous avons décider de pouvoir traiter facilement les musiques et les bruitages du jeu avec un mixeur. Nous avons donc crée une classe. L'HUD supérieur permet de la piloté à l'aide de trois sliders : Un pour le contrôle du volume de la musique, un pour celui des bruitages et un troisième englobant les deux, appelé master.

\subsection{Gestion des sauvegardes}
Pour la sauvegarde des parties, nous avons opté pour un système de enregistrement par fichier JSON. Ce qui nous permet d'avoir les données répartis sous forme hiérarchique et Qt possède toute une palette de fonction pour gérer des fichier JSON. Nous n'avions aucune connaissance de ce format.
\newline
Nous avions prévu deux types de fichier de sauvegarde : Un concernant une partie et un autre pour les configurations, celui-ci est le même pour n'importe quelles parties. Nous n'avons malheureusement pas eu le temps d'implémenter la sauvegarde de la configuration.
\newline
Quand aux données à sauvegarder, nous avons essayer de stocker un minimum d'information, pour éviter toute redondance. Comme par exemple le bonheur de la ville peut-être calculé avec nos fonctions. Il n'est donc pas sauvegarder dans le fichier. Un autre exemple qui est assez 'puissant' et nous permet d'éviter beaucoup d'information est la topographie de la carte, car en effet vu qu'elle est généré aléatoirement il nous suffi de stocker la seed et nous aurons toujours le même résultat.
\newline
Vous pouvez trouver un exemple de fichier de sauvegarde dans les annexes.

\section{Launcher}

\chapter{Tests}
\thispagestyle{headings}
\section{Protocoles de tests}


\chapter{Bilan}
\thispagestyle{headings}


\chapter{Conclusion}
\thispagestyle{headings}

\chapter{Source}
Pour le projet en général, nous avons principalement utilisé la documentation en ligne du framework Qt pour le développement.
\newline
Pour le utilisation du bruit de Perlin, nous avons consulté une série de vidéo tutoriel en javascript (avec le framework p5) de la chaîne Youtube "the CodingTrain" par Daniel Shiffman qui a couvert le sujet.
\newline
Pour ce qui est de l'algorithme de Perlin (en lui même) utilisé, il a été trouvé sur le compte Github de Sol-program :
\url{https://github.com/sol-prog/Perlin_Noise}

\chapter{Annexes}
\thispagestyle{headings}

\end{document}